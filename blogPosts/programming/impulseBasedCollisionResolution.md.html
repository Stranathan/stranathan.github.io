*While toying around with a little 2D physics project, I was unable to follow a popular online explanation of impulse
based collision resolution*

Contents
===================================================

1. Overview
2. Impulse Derivation
3. Problem Setup
4. Code example

Overview
===================================================
The change in motion of objects in a collision is caused by the forces generated at the collision point by compression and deformation.
This compression and deformation is too fast to simulate frame by for a rigid body.
Infinitesimal collision time allows us to assume an impulse model -- instantaneous change in velocity due to the collision.

Thus the movement after the collision can be calculated from the movement before the collision with an addition of an impulse.

Impulse Derivation
===================================================

Definition of momentum:

$$ \vec p = m \vec v$$

Newton's second law: $$\vec F = m\vec a = \frac{d}{dt} \left( m \vec v \right) = \frac{d \vec p}{dt}$$

Seperating variables and integrating:

$$\int_{t_1}^{t_2} \vec F \,dt = \int_{p_1}^{p_2} \vec dp \, = \vec p_2 - \vec p_1$$

This change in momentum is said to be impulse, let $\vec J$ be impulse:

Substituting original momentum expression:
$$\vec p_2 - \vec p_1 = m \vec v_2 - m \vec v_2$$

$$\frac{\vec p_2 - \vec p_1}{m} = \vec v_2 - \vec v_1$$

$$\vec v_2 = \vec v_1+ \frac{\vec p_2 - \vec p_1}{m}$$

$$\vec v_2 = \vec v_1+ \frac{\vec J}{m}$$


Problem Setup
===================================================

Consider two colliding objects, the shape is arbitrary, 
what's important is that a collision has somehow been detected and that a collision normal can be established.

![](../images/impulseBasedCollisionResolution/one.jpg)

From properties of dot products and normalized vectors, the magnitude of the velocities of the respective bodies along the relative position vector is:

$$\vec V_A \cdot \hat {\left( \vec r_B - \vec r_A \right)}$$
$$\vec V_B \cdot \hat {\left( \vec r_A - \vec r_B \right)}$$

![The magnitudes of respective velocities along relative position](../images/impulseBasedCollisionResolution/two.jpg)

Remembering that the sign of a dot prodct evinces the comparative direction of two vectors;
it's clear that if the sum of these two dot products is negative, the objects, although colliding during this frame, are moving 
away from each other, similarly, if the sum is positive then they're moving towards each other and the collision has to be resolved.

$$\vec V_A \cdot \hat {\left( \vec r_B - \vec r_A \right)} + \vec V_B \cdot \hat {\left( \vec r_A - \vec r_B \right)} < 0$$
$\implies$ moving away from each other
$$\vec V_A \cdot \hat {\left( \vec r_B - \vec r_A \right)} + \vec V_B \cdot \hat {\left( \vec r_A - \vec r_B \right)} > 0$$
$\implies$ moving toward each other

This value is called the closing velocity in the literature $v_c$

This is sloppy naming as it's a scalar value, but I'll stick with it for consistency.

In condensed form:

$$v_c = -\left( \vec v_A - \vec v_B \right) \cdot \left( \vec r_A - \vec v_B \right)$$

It's negation is often used instead, called the seperating velocity $v_s$ and its implications change accordingly.

$$v_s = \left( \vec v_A - \vec v_B \right) \cdot \left( \vec r_A - \vec v_B \right)$$

$v_s > 0 \implies$ moving away from each other.

$v_s < 0 \implies$ moving toward each other.

Recall that for a 
$$e = \frac {\lvert \vec v_2 \rvert}{\lvert \vec v_1 \rvert}$$

<p style="text-align: center;">[Wiki article for coefficient of restitution](https://en.wikipedia.org/wiki/Coefficient_of_restitution)
</p>



I think this is more or less a case of poisson's hypothesis.

~~~C
void ResolveCollision( A, B, MTV)
{
    let relativeVelocity = B.velocity - A.velocity
 
    // velocity in the direction of the minimum translation vector direction from SAT
    let velicityAlongNormal = vec2.dot(relativeVelocity, normal )
 
    // Do not resolve if velocities are separating
    if(velAlongNormal > 0)
        return;
 
    // Calculate restitution
    let e = Math.min( A.restitution, B.restitution)
 
    // Calculate impulse scalar
    float j = -(1 + e) * velAlongNormal
    j /= 1 / A.mass + 1 / B.mass
 
    // Apply impulse
    Vec2 impulse = j * normal
    A.velocity -= 1 / A.mass * impulse
    B.velocity += 1 / B.mass * impulse
}
~~~

---
Resources:

[Ian Millington - Game Physics Engine Development](https://www.amazon.com/Game-Physics-Engine-Development-Commercial-Grade/dp/0123819768)

[Randy Gaul - How to Create a Custom 2D Physics Engine: The Basics and Impulse Resolution](https://gamedevelopment.tutsplus.com/tutorials/how-to-create-a-custom-2d-physics-engine-the-basics-and-impulse-resolution--gamedev-6331?_ga=2.64050476.205125146.1625069373-736815224.1612468891)

[Brian Mirtich & John Canny - Impulse-based Simulation of Rigid Bodies](https://graphics.stanford.edu/courses/cs468-03-winter/Papers/ibsrb.pdf)

<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>